// ERD Explorer - Auto-documentation tool for Dataverse table relationships (v1.4 - Enhanced)
(async function () {
  const { createOverlay } = window.__lvlUpOverlay || (function(){ alert('Overlay helpers not loaded'); return {}; })();
  if (!createOverlay) return;
  const ui = createOverlay('ERD Explorer', { footer: true });
  if (ui.body) { ui.body.style.maxHeight = '85vh'; ui.body.style.overflowY = 'auto'; ui.body.style.paddingBottom = '20px'; if (ui.body.parentElement) { ui.body.parentElement.style.minWidth = '700px'; ui.body.parentElement.style.maxWidth = '900px'; ui.body.parentElement.style.maxHeight = '90vh'; } }
  try {
    const gc = Xrm.Utility.getGlobalContext(); const pc = Xrm.Utility.getPageContext && Xrm.Utility.getPageContext(); let currentEntity = (pc && pc.input && pc.input.entityName) || (Xrm.Page && Xrm.Page.data && Xrm.Page.data.entity && Xrm.Page.data.entity.getEntityName && Xrm.Page.data.entity.getEntityName());
    const ce = (tag) => document.createElement(tag); const txt = (el, t) => { el.textContent = t; return el; }; const style = (el, s) => { el.style.cssText = s; return el; }; const clearEl = (el) => { while (el.firstChild) el.removeChild(el.firstChild); };
    const apiBase = () => gc.getClientUrl() + '/api/data/v9.2'; const headers = () => ({ 'OData-MaxVersion': '4.0', 'OData-Version': '4.0', 'Accept': 'application/json', 'Content-Type': 'application/json' }); const fetchJson = async (path) => { const res = await fetch(apiBase() + path, { headers: headers() }); if (!res.ok) throw new Error('HTTP ' + res.status); return res.json(); };
    let collectedData = { tables: {}, relationships: [], relatedTables: new Set() }; let isRecording = false; let isMinimized = false; let lastRecordedEntity = null; let recordingIntervalId = null;
    
    // Add minimize button to header
    const minimizeBtn = ce('button');
    minimizeBtn.textContent = '\u2500'; // â”€ horizontal line (minimize)
    minimizeBtn.title = 'Minimize overlay';
    minimizeBtn.style.cssText = 'background:transparent;border:none;color:inherit;font-size:16px;cursor:pointer;padding:4px 8px;margin-right:4px;';
    if (ui.header && ui.close) {
      const headerBtns = ce('div');
      headerBtns.style.cssText = 'display:flex;align-items:center;gap:4px;';
      ui.header.removeChild(ui.close);
      headerBtns.appendChild(minimizeBtn);
      headerBtns.appendChild(ui.close);
      ui.header.appendChild(headerBtns);
    }
    const toggleMinimize = () => {
      isMinimized = !isMinimized;
      if (isMinimized) {
        ui.body.style.display = 'none';
        if (ui.footer) ui.footer.style.display = 'none';
        ui.host.style.maxHeight = 'none';
        minimizeBtn.textContent = '\u25A1'; // â–¡ square (restore)
        minimizeBtn.title = 'Restore overlay';
      } else {
        ui.body.style.display = '';
        if (ui.footer) ui.footer.style.display = '';
        ui.host.style.maxHeight = '90vh';
        minimizeBtn.textContent = '\u2500'; // â”€ horizontal line (minimize)
        minimizeBtn.title = 'Minimize overlay';
      }
    };
    minimizeBtn.addEventListener('click', toggleMinimize);
    
    // Auto-capture function for recording mode (interval-based polling for subgrid/lookup navigation)
    const checkAndCaptureCurrentTable = async () => {
      if (!isRecording) return;
      try {
        const pc2 = Xrm.Utility.getPageContext && Xrm.Utility.getPageContext();
        const entity = (pc2 && pc2.input && pc2.input.entityName) || (Xrm.Page && Xrm.Page.data && Xrm.Page.data.entity && Xrm.Page.data.entity.getEntityName && Xrm.Page.data.entity.getEntityName());
        if (entity && entity !== lastRecordedEntity && !collectedData.tables[entity]) {
          lastRecordedEntity = entity;
          currentEntity = entity;
          currentEntityName.textContent = entity;
          setStatus('ðŸ”´ Auto-capturing: ' + entity + '...');
          await analyzeTable(entity);
          addLog('Auto-captured table: ' + entity, 'info');
        }
      } catch (ex) { console.error('Auto-recording check failed:', ex); }
    };
    
    // Color scheme system
    const defaultColors = { light: { primary: '#0078d4', primaryHover: '#106ebe', border: '#ddd', borderLight: '#eee', text: '#323130', textMuted: '#605e5c', textError: '#a80000', bg: '#fff', bgHover: '#f3f2f1', bgError: '#fde7e9', textOnPrimary: '#fff', success: '#107c10', successHover: '#0e6b0e', danger: '#d13438', dangerHover: '#a80000', warning: '#ff0000' }, dark: { primary: '#60a5fa', primaryHover: '#3b82f6', border: '#374151', borderLight: '#4b5563', text: '#eef2ff', textMuted: '#9ca3af', textError: '#fca5a5', bg: '#1f2937', bgHover: '#374151', bgError: '#7f1d1d', textOnPrimary: '#fff', success: '#10b981', successHover: '#059669', danger: '#ef4444', dangerHover: '#dc2626', warning: '#f87171' } };
    let customColors = null; try { const stored = localStorage.getItem('crmab-erdexplorer-colors'); if (stored) customColors = JSON.parse(stored); } catch (ex) {}
    const getColors = () => { const isDark = ui.host.getAttribute('data-theme') === 'dark'; const mode = isDark ? 'dark' : 'light'; return (customColors && customColors[mode]) || defaultColors[mode]; };
    
    // Activity log system
    let activityLog = [];
    const addLog = (message, type) => { activityLog.push({ timestamp: new Date(), message, type: type || 'info' }); if (activityLog.length > 100) activityLog.shift(); };
    const c = getColors();
    const headerDiv = style(ce('div'), `margin:8px 0;padding:12px;background:${c.primary};color:${c.textOnPrimary};border-radius:4px;display:flex;justify-content:space-between;align-items:center;`); const titleSpan = txt(style(ce('span'), 'font-weight:600;font-size:14px;'), 'ðŸ“Š ERD Auto-Documentation'); const recordingDiv = style(ce('div'), 'display:flex;align-items:center;gap:8px;'); const recordingIndicator = style(ce('div'), `width:12px;height:12px;border-radius:50%;background:${c.warning};display:none;animation:blink 1.5s infinite;`); const recordingText = txt(style(ce('span'), 'font-size:12px;display:none;'), 'â— RECORDING'); recordingDiv.appendChild(recordingIndicator); recordingDiv.appendChild(recordingText); headerDiv.appendChild(titleSpan); headerDiv.appendChild(recordingDiv); ui.body.appendChild(headerDiv);
    if (!document.getElementById('erd-explorer-styles')) { const styleSheet = ce('style'); styleSheet.id = 'erd-explorer-styles'; styleSheet.textContent = `@keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }`; document.head.appendChild(styleSheet); }
    const currentEntityDiv = style(ce('div'), `margin:8px 0 12px 0;padding:8px;background:${c.bgHover};border-radius:4px;border-left:4px solid ${c.primary};`); currentEntityDiv.appendChild(document.createTextNode('Current Table: ')); const currentEntityName = txt(ce('b'), currentEntity || 'None found'); currentEntityDiv.appendChild(currentEntityName); ui.body.appendChild(currentEntityDiv);
    const controlsDiv = style(ce('div'), 'display:flex;gap:8px;margin:12px 0;flex-wrap:wrap;'); const btnStyle = (btn, isSecondary) => { btn.style.cssText = `background:${isSecondary?c.bg:c.bgHover};color:${c.text};border:1px solid ${c.border};padding:4px 10px;border-radius:3px;cursor:pointer;font-weight:500;font-size:12px;transition:all 0.2s;`; btn.addEventListener('mouseenter', function(){ this.style.background=c.primaryHover; this.style.borderColor=c.textMuted; }); btn.addEventListener('mouseleave', function(){ this.style.background=isSecondary?c.bg:c.bgHover; this.style.borderColor=c.border; }); };
    const recordingGroup = style(ce('div'), `display:flex;gap:4px;padding:6px;background:${c.bgHover};border-radius:4px;border:1px solid ${c.borderLight};`); const startBtn = txt(ce('button'), 'â–¶ Start'); btnStyle(startBtn); const stopBtn = txt(ce('button'), 'â¸ Stop'); btnStyle(stopBtn); stopBtn.disabled = true; stopBtn.style.opacity = '0.5'; const captureBtn = txt(ce('button'), 'ðŸ“¸ Capture'); btnStyle(captureBtn); recordingGroup.appendChild(startBtn); recordingGroup.appendChild(stopBtn); recordingGroup.appendChild(captureBtn);
    const jsonGroup = style(ce('div'), `display:flex;gap:4px;padding:6px;background:${c.bgHover};border-radius:4px;border:1px solid ${c.borderLight};`); const importJsonBtn = txt(ce('button'), 'â†‘ Import JSON'); btnStyle(importJsonBtn); const exportJsonBtn = txt(ce('button'), 'â†“ Export JSON'); btnStyle(exportJsonBtn); jsonGroup.appendChild(importJsonBtn); jsonGroup.appendChild(exportJsonBtn);
    const erdGroup = style(ce('div'), `display:flex;gap:4px;padding:6px;background:${c.bgHover};border-radius:4px;border:1px solid ${c.borderLight};`); const importMermaidBtn = txt(ce('button'), 'â†‘ Import ERD'); btnStyle(importMermaidBtn); const exportMermaidBtn = txt(ce('button'), 'â†“ Export ERD'); btnStyle(exportMermaidBtn); const viewMermaidBtn = txt(ce('button'), 'ðŸ‘ View ERD'); btnStyle(viewMermaidBtn); erdGroup.appendChild(importMermaidBtn); erdGroup.appendChild(exportMermaidBtn); erdGroup.appendChild(viewMermaidBtn);
    const clearGroup = style(ce('div'), 'padding:6px;'); const clearBtn = txt(ce('button'), 'ðŸ—‘ Clear'); btnStyle(clearBtn, true); clearGroup.appendChild(clearBtn);
    controlsDiv.appendChild(recordingGroup); controlsDiv.appendChild(jsonGroup); controlsDiv.appendChild(erdGroup); controlsDiv.appendChild(clearGroup); ui.body.appendChild(controlsDiv);
    const mermaidOptionsDiv = style(ce('div'), `margin:8px 0;padding:10px;background:${c.bgHover};border-radius:4px;display:flex;align-items:center;gap:12px;flex-wrap:wrap;`); const mermaidOptionsLabel = txt(style(ce('span'), `font-weight:600;font-size:12px;color:${c.text};`), 'Mermaid ERD Mode:'); const mermaidModeRadio1 = ce('input'); mermaidModeRadio1.type = 'radio'; mermaidModeRadio1.name = 'mermaidMode'; mermaidModeRadio1.value = 'optimized'; mermaidModeRadio1.id = 'mode-opt'; mermaidModeRadio1.checked = true; const mermaidModeLabel1 = ce('label'); mermaidModeLabel1.htmlFor = 'mode-opt'; mermaidModeLabel1.style.cssText = `font-size:12px;color:${c.text};cursor:pointer;display:flex;align-items:center;gap:4px;`; mermaidModeLabel1.appendChild(mermaidModeRadio1); mermaidModeLabel1.appendChild(document.createTextNode('ðŸŽ¯ Optimized (Primary, Keys, Lookups)')); const mermaidModeRadio2 = ce('input'); mermaidModeRadio2.type = 'radio'; mermaidModeRadio2.name = 'mermaidMode'; mermaidModeRadio2.value = 'full'; mermaidModeRadio2.id = 'mode-full'; const mermaidModeLabel2 = ce('label'); mermaidModeLabel2.htmlFor = 'mode-full'; mermaidModeLabel2.style.cssText = `font-size:12px;color:${c.text};cursor:pointer;display:flex;align-items:center;gap:4px;`; mermaidModeLabel2.appendChild(mermaidModeRadio2); mermaidModeLabel2.appendChild(document.createTextNode('ðŸ“‹ Complete (all fields)')); const mermaidModeRadio3 = ce('input'); mermaidModeRadio3.type = 'radio'; mermaidModeRadio3.name = 'mermaidMode'; mermaidModeRadio3.value = 'tablesonly'; mermaidModeRadio3.id = 'mode-tables'; const mermaidModeLabel3 = ce('label'); mermaidModeLabel3.htmlFor = 'mode-tables'; mermaidModeLabel3.style.cssText = `font-size:12px;color:${c.text};cursor:pointer;display:flex;align-items:center;gap:4px;`; mermaidModeLabel3.appendChild(mermaidModeRadio3); mermaidModeLabel3.appendChild(document.createTextNode('ðŸ“¦ Tables Only (no fields)')); const mermaidModeRadio4 = ce('input'); mermaidModeRadio4.type = 'radio'; mermaidModeRadio4.name = 'mermaidMode'; mermaidModeRadio4.value = 'custom'; mermaidModeRadio4.id = 'mode-custom'; const mermaidModeLabel4 = ce('label'); mermaidModeLabel4.htmlFor = 'mode-custom'; mermaidModeLabel4.style.cssText = `font-size:12px;color:${c.text};cursor:pointer;display:flex;align-items:center;gap:4px;`; mermaidModeLabel4.appendChild(mermaidModeRadio4); mermaidModeLabel4.appendChild(document.createTextNode('âœï¸ Custom (per-table selection)')); mermaidOptionsDiv.appendChild(mermaidOptionsLabel); mermaidOptionsDiv.appendChild(mermaidModeLabel1); mermaidOptionsDiv.appendChild(mermaidModeLabel2); mermaidOptionsDiv.appendChild(mermaidModeLabel3); mermaidOptionsDiv.appendChild(mermaidModeLabel4); const hideSelfRefCheckbox = ce('input'); hideSelfRefCheckbox.type = 'checkbox'; hideSelfRefCheckbox.id = 'hide-self-ref'; hideSelfRefCheckbox.style.cssText = 'margin-left:16px;'; const hideSelfRefLabel = ce('label'); hideSelfRefLabel.htmlFor = 'hide-self-ref'; hideSelfRefLabel.style.cssText = `font-size:12px;color:${c.text};cursor:pointer;display:flex;align-items:center;gap:4px;`; hideSelfRefLabel.appendChild(hideSelfRefCheckbox); hideSelfRefLabel.appendChild(document.createTextNode('ðŸ”„ Hide self-referencing')); mermaidOptionsDiv.appendChild(hideSelfRefLabel); ui.body.appendChild(mermaidOptionsDiv);
    const statusDiv = style(ce('div'), `margin:8px 0;padding:8px;background:${c.bg};border:1px solid ${c.border};border-radius:4px;font-size:12px;color:${c.textMuted};`); statusDiv.textContent = 'Ready. Click "Start Recording" or capture the current table.'; ui.body.appendChild(statusDiv); const setStatus = (m, isError) => { statusDiv.textContent = m; statusDiv.style.color = isError ? c.textError : c.textMuted; statusDiv.style.background = isError ? c.bgError : c.bg; if (m) addLog(m, isError ? 'error' : 'info'); };
    const statsDiv = style(ce('div'), `margin:12px 0;padding:12px;background:${c.bg};border:1px solid ${c.border};border-radius:4px;display:flex;gap:16px;justify-content:space-around;flex-wrap:wrap;`); const createStatBox = (label, value) => { const box = style(ce('div'), 'flex:1;min-width:120px;text-align:center;'); box.appendChild(txt(style(ce('div'), `font-size:24px;font-weight:600;color:${c.primary};`), value)); box.appendChild(txt(style(ce('div'), `font-size:11px;color:${c.textMuted};text-transform:uppercase;margin-top:4px;`), label)); return box; }; const tablesStatBox = createStatBox('Tables', '0'); const relationshipsStatBox = createStatBox('Relationships', '0'); const fieldsStatBox = createStatBox('Fields', '0'); statsDiv.appendChild(tablesStatBox); statsDiv.appendChild(relationshipsStatBox); statsDiv.appendChild(fieldsStatBox); ui.body.appendChild(statsDiv);
    const updateStats = () => { const tableCount = Object.keys(collectedData.tables).length; const relationshipCount = collectedData.relationships.length; const fieldCount = Object.values(collectedData.tables).reduce((sum, t) => sum + (t.fields ? t.fields.length : 0), 0); tablesStatBox.firstChild.textContent = tableCount; relationshipsStatBox.firstChild.textContent = relationshipCount; fieldsStatBox.firstChild.textContent = fieldCount; };
    const tablesTitle = txt(style(ce('div'), `font-weight:600;margin:16px 0 8px 0;padding:8px 0;border-bottom:2px solid ${c.primary};`), 'Captured Tables'); ui.body.appendChild(tablesTitle); const tablesList = style(ce('div'), `border:1px solid ${c.border};border-radius:4px;max-height:300px;overflow-y:auto;background:${c.bg};`); const tablesListEmpty = txt(style(ce('div'), `padding:20px;text-align:center;color:${c.textMuted};`), 'No tables captured yet.'); tablesList.appendChild(tablesListEmpty); ui.body.appendChild(tablesList);
    const relatedTablesTitle = txt(style(ce('div'), `font-weight:600;margin:16px 0 8px 0;padding:8px 0;border-bottom:2px solid ${c.success};`), 'Related Tables (found via Relationships)'); ui.body.appendChild(relatedTablesTitle);
    const relatedSearchDiv = style(ce('div'), `padding:8px;background:${c.bgHover};border:1px solid ${c.border};border-bottom:none;border-radius:4px 4px 0 0;`);
    const relatedSearchInput = ce('input'); relatedSearchInput.type = 'text'; relatedSearchInput.placeholder = 'ðŸ” Search related tables...'; relatedSearchInput.style.cssText = `width:100%;padding:6px 10px;border:1px solid ${c.border};border-radius:3px;font-size:12px;box-sizing:border-box;background:${c.bg};color:${c.text};`;
    relatedSearchDiv.appendChild(relatedSearchInput); ui.body.appendChild(relatedSearchDiv);
    const relatedTablesList = style(ce('div'), `border:1px solid ${c.border};border-radius:0 0 4px 4px;max-height:200px;overflow-y:auto;background:${c.bg};`); const relatedTablesListEmpty = txt(style(ce('div'), `padding:16px;text-align:center;color:${c.textMuted};font-size:11px;`), 'No related tables found yet. Capture a table to see relationships.'); relatedTablesList.appendChild(relatedTablesListEmpty); ui.body.appendChild(relatedTablesList);
    const showFieldsSelector = (table) => { const cf = getColors(); const fieldsOverlay = window.__lvlUpOverlay.createOverlay('Select Fields: ' + (table.displayName || table.logicalName), { width: 600, rootId: 'erd-fields-overlay-' + table.logicalName }); if (!fieldsOverlay) return; if (fieldsOverlay.host) { fieldsOverlay.host.style.zIndex = '9999990'; } fieldsOverlay.body.style.maxHeight = '70vh'; fieldsOverlay.body.style.overflowY = 'auto'; const currentMode = document.querySelector('input[name="mermaidMode"]:checked').value; let selectedFields = new Set(); if (table.customFields && Array.isArray(table.customFields)) { table.customFields.forEach(fn => selectedFields.add(fn)); } else if (currentMode === 'full') { (table.fields || []).forEach(f => selectedFields.add(f.logicalName)); } else if (currentMode === 'optimized') { const usedFieldNames = new Set(); collectedData.relationships.forEach(r => { if (r.referencingEntity === table.logicalName && r.referencingAttribute) usedFieldNames.add(r.referencingAttribute.toLowerCase()); if (r.referencedEntity === table.logicalName && r.referencedAttribute) usedFieldNames.add(r.referencedAttribute.toLowerCase()); }); (table.fields || []).filter(field => { const ln = field.logicalName.toLowerCase(); return field.isPrimaryId || field.isPrimaryName || usedFieldNames.has(ln); }).forEach(f => selectedFields.add(f.logicalName)); } const headerDiv = style(ce('div'), `padding:12px;background:${cf.bgHover};border-radius:4px;margin-bottom:12px;`); const searchInput = ce('input'); searchInput.type = 'text'; searchInput.placeholder = 'ðŸ” Filter fields...'; searchInput.style.cssText = `width:100%;padding:8px 12px;border:1px solid ${cf.border};border-radius:4px;font-size:13px;box-sizing:border-box;background:${cf.bg};color:${cf.text};margin-bottom:8px;`; headerDiv.appendChild(searchInput); const selectionInfo = style(ce('div'), `font-size:12px;color:${cf.textMuted};display:flex;justify-content:space-between;align-items:center;`); const selectionCount = ce('span'); selectionCount.textContent = selectedFields.size + ' of ' + (table.fields ? table.fields.length : 0) + ' fields selected'; const buttonGroup = style(ce('div'), 'display:flex;gap:8px;'); const selectAllBtn = txt(ce('button'), 'Select All'); selectAllBtn.style.cssText = `padding:4px 8px;font-size:11px;background:${cf.bg};border:1px solid ${cf.border};border-radius:3px;cursor:pointer;color:${cf.text};`; const selectNoneBtn = txt(ce('button'), 'Select None'); selectNoneBtn.style.cssText = `padding:4px 8px;font-size:11px;background:${cf.bg};border:1px solid ${cf.border};border-radius:3px;cursor:pointer;color:${cf.text};`; buttonGroup.appendChild(selectAllBtn); buttonGroup.appendChild(selectNoneBtn); selectionInfo.appendChild(selectionCount); selectionInfo.appendChild(buttonGroup); headerDiv.appendChild(selectionInfo); fieldsOverlay.body.appendChild(headerDiv); const fieldsListContainer = style(ce('div'), `border:1px solid ${cf.border};border-radius:4px;max-height:400px;overflow-y:auto;background:${cf.bg};`); const updateSelectionCount = () => { selectionCount.textContent = selectedFields.size + ' of ' + (table.fields ? table.fields.length : 0) + ' fields selected'; }; const renderFieldsList = (filterText) => { clearEl(fieldsListContainer); const filter = (filterText || '').toLowerCase(); const sortedFields = (table.fields || []).slice().sort((a, b) => { if (a.isPrimaryId && !b.isPrimaryId) return -1; if (!a.isPrimaryId && b.isPrimaryId) return 1; if (a.isPrimaryName && !b.isPrimaryName) return -1; if (!a.isPrimaryName && b.isPrimaryName) return 1; return a.logicalName.localeCompare(b.logicalName); }); let visibleCount = 0; sortedFields.forEach(field => { const matchesFilter = !filter || field.logicalName.toLowerCase().indexOf(filter) !== -1 || (field.displayName && field.displayName.toLowerCase().indexOf(filter) !== -1) || field.type.toLowerCase().indexOf(filter) !== -1; if (!matchesFilter) return; visibleCount++; const row = style(ce('div'), `padding:8px 12px;border-bottom:1px solid ${cf.borderLight};display:flex;align-items:center;gap:10px;cursor:pointer;`); row.addEventListener('mouseenter', function(){ this.style.background = cf.bgHover; }); row.addEventListener('mouseleave', function(){ this.style.background = selectedFields.has(field.logicalName) ? cf.bgHover : ''; }); if (selectedFields.has(field.logicalName)) { row.style.background = cf.bgHover; } const checkbox = ce('input'); checkbox.type = 'checkbox'; checkbox.checked = selectedFields.has(field.logicalName); checkbox.style.cssText = 'width:16px;height:16px;cursor:pointer;flex-shrink:0;'; const fieldInfo = ce('div'); fieldInfo.style.flex = '1'; const fieldName = style(ce('div'), `font-weight:500;color:${cf.text};font-size:13px;`); fieldName.textContent = field.logicalName; if (field.isPrimaryId) { const pkBadge = txt(style(ce('span'), `margin-left:6px;padding:1px 5px;background:${cf.primary};color:${cf.textOnPrimary};border-radius:3px;font-size:10px;font-weight:600;`), 'PK'); fieldName.appendChild(pkBadge); } if (field.isPrimaryName) { const nameBadge = txt(style(ce('span'), `margin-left:6px;padding:1px 5px;background:${cf.success};color:${cf.textOnPrimary};border-radius:3px;font-size:10px;font-weight:600;`), 'NAME'); fieldName.appendChild(nameBadge); } const fieldDetails = style(ce('div'), `font-size:11px;color:${cf.textMuted};margin-top:2px;`); fieldDetails.textContent = (field.displayName || '') + ' â€¢ ' + field.type; fieldInfo.appendChild(fieldName); fieldInfo.appendChild(fieldDetails); const typeLabel = txt(style(ce('span'), `font-size:11px;color:${cf.textMuted};background:${cf.bgHover};padding:2px 6px;border-radius:3px;flex-shrink:0;`), field.type); const toggleSelection = () => { if (selectedFields.has(field.logicalName)) { selectedFields.delete(field.logicalName); checkbox.checked = false; row.style.background = ''; } else { selectedFields.add(field.logicalName); checkbox.checked = true; row.style.background = cf.bgHover; } updateSelectionCount(); }; row.addEventListener('click', (e) => { if (e.target !== checkbox) { toggleSelection(); } }); checkbox.addEventListener('change', () => { if (checkbox.checked) { selectedFields.add(field.logicalName); row.style.background = cf.bgHover; } else { selectedFields.delete(field.logicalName); row.style.background = ''; } updateSelectionCount(); }); row.appendChild(checkbox); row.appendChild(fieldInfo); row.appendChild(typeLabel); fieldsListContainer.appendChild(row); }); if (visibleCount === 0) { const noResults = txt(style(ce('div'), `padding:20px;text-align:center;color:${cf.textMuted};`), 'No fields match the filter.'); fieldsListContainer.appendChild(noResults); } }; renderFieldsList(''); fieldsOverlay.body.appendChild(fieldsListContainer); searchInput.addEventListener('input', function() { renderFieldsList(this.value); }); selectAllBtn.addEventListener('click', () => { (table.fields || []).forEach(f => selectedFields.add(f.logicalName)); updateSelectionCount(); renderFieldsList(searchInput.value); }); selectNoneBtn.addEventListener('click', () => { selectedFields.clear(); updateSelectionCount(); renderFieldsList(searchInput.value); }); const footerDiv = style(ce('div'), `display:flex;gap:8px;margin-top:16px;padding-top:12px;border-top:1px solid ${cf.border};`); const saveBtn = txt(ce('button'), 'ðŸ’¾ Save Selection'); saveBtn.style.cssText = `flex:1;padding:10px 16px;background:${cf.primary};color:${cf.textOnPrimary};border:none;border-radius:4px;cursor:pointer;font-weight:600;font-size:13px;`; saveBtn.addEventListener('mouseenter', function(){ this.style.background = cf.primaryHover; }); saveBtn.addEventListener('mouseleave', function(){ this.style.background = cf.primary; }); const cancelBtn = txt(ce('button'), 'âœ– Cancel'); cancelBtn.style.cssText = `flex:1;padding:10px 16px;background:${cf.bgHover};color:${cf.text};border:1px solid ${cf.border};border-radius:4px;cursor:pointer;font-weight:600;font-size:13px;`; saveBtn.addEventListener('click', () => { table.customFields = Array.from(selectedFields); const customModeRadio = document.getElementById('mode-custom'); if (customModeRadio) { customModeRadio.checked = true; } addLog('Custom fields saved for ' + table.logicalName + ' (' + selectedFields.size + ' fields)', 'info'); setStatus('âœ“ Custom field selection saved for ' + (table.displayName || table.logicalName)); updateTablesList(); fieldsOverlay.closeOverlay(); }); cancelBtn.addEventListener('click', () => { fieldsOverlay.closeOverlay(); }); footerDiv.appendChild(saveBtn); footerDiv.appendChild(cancelBtn); fieldsOverlay.body.appendChild(footerDiv); }; const updateTablesList = () => { clearEl(tablesList); const tables = Object.values(collectedData.tables); if (tables.length === 0) { tablesList.appendChild(txt(style(ce('div'), `padding:20px;text-align:center;color:${c.textMuted};`), 'No tables captured yet.')); return; } tables.forEach(table => { const row = style(ce('div'), `padding:10px 12px;border-bottom:1px solid ${c.borderLight};display:flex;justify-content:space-between;align-items:center;`); row.addEventListener('mouseenter', function(){ this.style.background=c.bgHover; }); row.addEventListener('mouseleave', function(){ this.style.background=''; }); const infoDiv = ce('div'); infoDiv.style.flex = '1'; const nameDiv = style(ce('div'), `font-weight:600;color:${c.text};margin-bottom:4px;`); nameDiv.textContent = table.displayName || table.logicalName; if (table.customFields && Array.isArray(table.customFields)) { const customBadge = txt(style(ce('span'), `margin-left:8px;padding:2px 6px;background:${c.primary};color:${c.textOnPrimary};border-radius:3px;font-size:10px;font-weight:600;`), 'CUSTOM: ' + table.customFields.length); nameDiv.appendChild(customBadge); } const detailsDiv = style(ce('div'), `font-size:11px;color:${c.textMuted};`); detailsDiv.textContent = table.logicalName + ' â€¢ ' + (table.fields ? table.fields.length : 0) + ' Fields â€¢ ' + (table.relationshipsCount || 0) + ' Relationships'; infoDiv.appendChild(nameDiv); infoDiv.appendChild(detailsDiv); const btnGroup = style(ce('div'), 'display:flex;gap:6px;'); const fieldsBtn = txt(ce('button'), 'ðŸ“‹ Fields'); fieldsBtn.style.cssText = 'background:' + c.primary + ';color:' + c.textOnPrimary + ';border:none;padding:4px 10px;border-radius:3px;cursor:pointer;font-size:12px;font-weight:500;'; fieldsBtn.title = 'Select fields for ERD'; fieldsBtn.addEventListener('mouseenter', function(){ this.style.background = c.primaryHover; }); fieldsBtn.addEventListener('mouseleave', function(){ this.style.background = c.primary; }); fieldsBtn.addEventListener('click', (e) => { e.stopPropagation(); showFieldsSelector(table); }); const removeBtn = txt(ce('button'), 'ðŸ—‘'); removeBtn.style.cssText = 'background:' + c.danger + ';color:' + c.textOnPrimary + ';border:none;padding:4px 10px;border-radius:3px;cursor:pointer;font-size:14px;'; removeBtn.title = 'Remove table'; removeBtn.addEventListener('mouseenter', function(){ this.style.background=c.dangerHover; }); removeBtn.addEventListener('mouseleave', function(){ this.style.background=c.danger; }); removeBtn.addEventListener('click', (e) => { e.stopPropagation(); if (!confirm('Remove table "' + (table.displayName || table.logicalName) + '"?')) return; delete collectedData.tables[table.logicalName]; collectedData.relationships = collectedData.relationships.filter(r => r.referencedEntity !== table.logicalName && r.referencingEntity !== table.logicalName && r.entity1 !== table.logicalName && r.entity2 !== table.logicalName); addLog('Removed table: ' + table.logicalName, 'info'); updateStats(); updateTablesList(); updateRelatedTablesList(); }); btnGroup.appendChild(fieldsBtn); btnGroup.appendChild(removeBtn); row.appendChild(infoDiv); row.appendChild(btnGroup); tablesList.appendChild(row); }); };
    const updateRelatedTablesList = () => { clearEl(relatedTablesList); const related = Array.from(collectedData.relatedTables).filter(t => !collectedData.tables[t]).sort((a, b) => a.localeCompare(b)); if (related.length === 0) { relatedTablesList.appendChild(txt(style(ce('div'), `padding:16px;text-align:center;color:${c.textMuted};font-size:11px;`), related.length === 0 && Object.keys(collectedData.tables).length > 0 ? 'All related tables already captured.' : 'No related tables found yet.')); return; } related.forEach(tableName => { const row = style(ce('div'), `padding:8px 12px;border-bottom:1px solid ${c.borderLight};display:flex;justify-content:space-between;align-items:center;`); row.setAttribute('data-table-name', tableName.toLowerCase()); row.addEventListener('mouseenter', function(){ this.style.background=c.bgHover; }); row.addEventListener('mouseleave', function(){ this.style.background=''; }); const nameDiv = style(ce('div'), `font-weight:600;color:${c.text};font-size:12px;`); nameDiv.textContent = tableName; const addBtn = txt(ce('button'), '+ Add'); addBtn.style.cssText = 'background:' + c.success + ';color:' + c.textOnPrimary + ';border:none;padding:4px 12px;border-radius:3px;cursor:pointer;font-size:11px;font-weight:600;'; addBtn.addEventListener('mouseenter', function(){ this.style.background=c.successHover; }); addBtn.addEventListener('mouseleave', function(){ this.style.background=c.success; }); addBtn.addEventListener('click', async (e) => { e.stopPropagation(); await analyzeTable(tableName); }); row.appendChild(nameDiv); row.appendChild(addBtn); relatedTablesList.appendChild(row); }); };
    relatedSearchInput.addEventListener('input', function() { const query = this.value.toLowerCase(); Array.from(relatedTablesList.children).forEach(row => { const tableName = row.getAttribute('data-table-name'); if (tableName) { row.style.display = tableName.includes(query) ? '' : 'none'; } }); });
    const analyzeTable = async (entityLogicalName) => { if (!entityLogicalName) { setStatus('No valid table specified.', true); return null; } setStatus(`Analyzing table: ${entityLogicalName}...`); const sq = String.fromCharCode(39); try { const entityMeta = await fetchJson(`/EntityDefinitions(LogicalName=${encodeURIComponent(sq + entityLogicalName + sq)})?$select=LogicalName,SchemaName,DisplayName,PrimaryIdAttribute,PrimaryNameAttribute,EntitySetName,Description&$expand=Attributes($select=LogicalName,AttributeType,DisplayName,Description,IsPrimaryId,IsPrimaryName;$filter=IsValidForRead eq true),OneToManyRelationships($select=SchemaName,ReferencedEntity,ReferencedAttribute,ReferencingEntity,ReferencingAttribute),ManyToOneRelationships($select=SchemaName,ReferencedEntity,ReferencedAttribute,ReferencingEntity,ReferencingAttribute),ManyToManyRelationships($select=SchemaName,Entity1LogicalName,Entity2LogicalName,IntersectEntityName)`); const tableData = { logicalName: entityMeta.LogicalName, schemaName: entityMeta.SchemaName, displayName: entityMeta.DisplayName?.UserLocalizedLabel?.Label || entityMeta.LogicalName, primaryIdAttribute: entityMeta.PrimaryIdAttribute, primaryNameAttribute: entityMeta.PrimaryNameAttribute, entitySetName: entityMeta.EntitySetName, description: entityMeta.Description?.UserLocalizedLabel?.Label || '', fields: [], relationshipsCount: 0 }; if (entityMeta.Attributes) { entityMeta.Attributes.forEach(attr => { const field = { logicalName: attr.LogicalName, type: mapAttributeType(attr.AttributeType), displayName: attr.DisplayName?.UserLocalizedLabel?.Label || attr.LogicalName, description: attr.Description?.UserLocalizedLabel?.Label || '', isPrimaryId: attr.IsPrimaryId || false, isPrimaryName: attr.IsPrimaryName || false }; tableData.fields.push(field); }); } const processRelationships = (rels, type) => { if (!rels) return 0; let count = 0; rels.forEach(rel => { const relData = { schemaName: rel.SchemaName, type: type, referencedEntity: rel.ReferencedEntity, referencedAttribute: rel.ReferencedAttribute, referencingEntity: rel.ReferencingEntity, referencingAttribute: rel.ReferencingAttribute }; const exists = collectedData.relationships.some(r => r.schemaName === relData.schemaName); if (!exists) { collectedData.relationships.push(relData); count++; } const relatedEntity = type === 'OneToMany' ? rel.ReferencingEntity : rel.ReferencedEntity; if (relatedEntity && relatedEntity !== entityLogicalName) { collectedData.relatedTables.add(relatedEntity); } }); return count; }; let relCount = 0; if (entityMeta.OneToManyRelationships) { relCount += processRelationships(entityMeta.OneToManyRelationships, 'OneToMany'); } if (entityMeta.ManyToOneRelationships) { relCount += processRelationships(entityMeta.ManyToOneRelationships, 'ManyToOne'); } if (entityMeta.ManyToManyRelationships) { entityMeta.ManyToManyRelationships.forEach(rel => { const relData = { schemaName: rel.SchemaName, type: 'ManyToMany', entity1: rel.Entity1LogicalName, entity2: rel.Entity2LogicalName, intersectEntity: rel.IntersectEntityName }; const exists = collectedData.relationships.some(r => r.schemaName === relData.schemaName); if (!exists) { collectedData.relationships.push(relData); relCount++; } if (rel.Entity1LogicalName !== entityLogicalName) collectedData.relatedTables.add(rel.Entity1LogicalName); if (rel.Entity2LogicalName !== entityLogicalName) collectedData.relatedTables.add(rel.Entity2LogicalName); }); } tableData.relationshipsCount = relCount; if (!collectedData.tables[entityLogicalName]) { collectedData.tables[entityLogicalName] = tableData; } else { collectedData.tables[entityLogicalName] = { ...collectedData.tables[entityLogicalName], ...tableData }; } setStatus(`âœ“ Table "${tableData.displayName}" captured: ${tableData.fields.length} Fields, ${relCount} new Relationships`); updateStats(); updateTablesList(); updateRelatedTablesList(); return tableData; } catch (ex) { console.error(ex); setStatus(`Error analyzing ${entityLogicalName}: ${ex.message}`, true); return null; } };
    const mapAttributeType = (attrType) => { const typeMap = { 'String': 'string', 'Memo': 'memo', 'Integer': 'int', 'BigInt': 'bigint', 'Decimal': 'decimal', 'Double': 'float', 'Money': 'money', 'Boolean': 'boolean', 'DateTime': 'datetime', 'Lookup': 'lookup', 'Customer': 'lookup', 'Owner': 'lookup', 'Uniqueidentifier': 'guid', 'Picklist': 'picklist', 'State': 'state', 'Status': 'status', 'Virtual': 'virtual', 'ManagedProperty': 'managedproperty', 'EntityName': 'entityname' }; return typeMap[attrType] || attrType.toLowerCase(); };
    const getFieldsForMode = (table, mode) => { if (mode === 'tablesonly') { return []; } if (mode === 'custom') { if (table.customFields && Array.isArray(table.customFields) && table.customFields.length > 0) { const customFieldSet = new Set(table.customFields); return (table.fields || []).filter(field => customFieldSet.has(field.logicalName)); } return []; } if (mode === 'optimized') { const usedFieldNames = new Set(); collectedData.relationships.forEach(r => { if (r.referencingEntity === table.logicalName && r.referencingAttribute) usedFieldNames.add(r.referencingAttribute.toLowerCase()); if (r.referencedEntity === table.logicalName && r.referencedAttribute) usedFieldNames.add(r.referencedAttribute.toLowerCase()); }); return (table.fields || []).filter(field => { const ln = field.logicalName.toLowerCase(); return field.isPrimaryId || field.isPrimaryName || usedFieldNames.has(ln); }); } return table.fields || []; };
    const filterRelationships = (relationships, hideSelfReferencing) => { if (!hideSelfReferencing) return relationships; return relationships.filter(rel => { const isSelfRef = (rel.type === 'ManyToMany' && rel.entity1 === rel.entity2) || (rel.type !== 'ManyToMany' && rel.referencedEntity === rel.referencingEntity); return !isSelfRef; }); };
    const filterRelationshipsForMode = (relationships, mode, filteredTables, hideSelfReferencing) => { const tableNames = new Set(Object.keys(filteredTables)); let result = relationships; if (hideSelfReferencing) { result = result.filter(rel => { const isSelfRef = (rel.type === 'ManyToMany' && rel.entity1 === rel.entity2) || (rel.type !== 'ManyToMany' && rel.referencedEntity === rel.referencingEntity); return !isSelfRef; }); } if (mode === 'full') { return result.filter(rel => { if (rel.type === 'ManyToMany') { return tableNames.has(rel.entity1) && tableNames.has(rel.entity2); } return tableNames.has(rel.referencedEntity) && tableNames.has(rel.referencingEntity); }); } if (mode === 'tablesonly') { return result.filter(rel => { if (rel.type === 'ManyToMany') { return tableNames.has(rel.entity1) && tableNames.has(rel.entity2); } return tableNames.has(rel.referencedEntity) && tableNames.has(rel.referencingEntity); }); } if (mode === 'optimized') { const relevantFieldNames = new Set(); Object.values(filteredTables).forEach(table => { (table.fields || []).forEach(field => { relevantFieldNames.add(table.logicalName + '.' + field.logicalName.toLowerCase()); }); }); return result.filter(rel => { if (rel.type === 'ManyToMany') { return tableNames.has(rel.entity1) && tableNames.has(rel.entity2); } const bothTablesPresent = tableNames.has(rel.referencedEntity) && tableNames.has(rel.referencingEntity); if (!bothTablesPresent) return false; const refAttrKey = rel.referencedEntity + '.' + (rel.referencedAttribute || '').toLowerCase(); const refingAttrKey = rel.referencingEntity + '.' + (rel.referencingAttribute || '').toLowerCase(); return relevantFieldNames.has(refAttrKey) || relevantFieldNames.has(refingAttrKey); }); } if (mode === 'custom') { const relevantFieldNames = new Set(); Object.values(filteredTables).forEach(table => { (table.fields || []).forEach(field => { relevantFieldNames.add(table.logicalName + '.' + field.logicalName.toLowerCase()); }); }); return result.filter(rel => { if (rel.type === 'ManyToMany') { return tableNames.has(rel.entity1) && tableNames.has(rel.entity2); } const bothTablesPresent = tableNames.has(rel.referencedEntity) && tableNames.has(rel.referencingEntity); if (!bothTablesPresent) return false; const refAttrKey = rel.referencedEntity + '.' + (rel.referencedAttribute || '').toLowerCase(); const refingAttrKey = rel.referencingEntity + '.' + (rel.referencingAttribute || '').toLowerCase(); return relevantFieldNames.has(refAttrKey) || relevantFieldNames.has(refingAttrKey); }); } return result; };
    const generateMermaid = (mode, hideSelfReferencing) => {
      let mermaid = 'erDiagram\n';
      Object.values(collectedData.tables).forEach(table => {
        mermaid += `    ${table.schemaName || table.logicalName} {\n`;
        const fieldsToInclude = getFieldsForMode(table, mode);
        fieldsToInclude.forEach(field => {
          let line = `        ${field.type} ${field.logicalName}`;
          if (field.isPrimaryId) line += ' PK';
          if (field.logicalName.endsWith('id') && !field.isPrimaryId) line += ' FK';
          if (field.displayName) line += ` "${field.displayName}"`;
          mermaid += line + '\n';
        });
        mermaid += '    }\n\n';
      });
      collectedData.relationships.forEach(rel => {
        if (hideSelfReferencing) {
          const isSelfRef = (rel.type === 'ManyToMany' && rel.entity1 === rel.entity2) || (rel.type !== 'ManyToMany' && rel.referencedEntity === rel.referencingEntity);
          if (isSelfRef) return;
        }
        let line = '';
        if (rel.type === 'OneToMany') {
          const refTable = collectedData.tables[rel.referencedEntity];
          const refingTable = collectedData.tables[rel.referencingEntity];
          if (refTable && refingTable) { line = `    ${refTable.schemaName || rel.referencedEntity} ||--o{ ${refingTable.schemaName || rel.referencingEntity} : "${rel.schemaName}"`; }
        } else if (rel.type === 'ManyToOne') {
          const refTable = collectedData.tables[rel.referencedEntity];
          const refingTable = collectedData.tables[rel.referencingEntity];
          if (refTable && refingTable) { line = `    ${refingTable.schemaName || rel.referencingEntity} }o--|| ${refTable.schemaName || rel.referencedEntity} : "${rel.schemaName}"`; }
        } else if (rel.type === 'ManyToMany') {
          const table1 = collectedData.tables[rel.entity1];
          const table2 = collectedData.tables[rel.entity2];
          if (table1 && table2) { line = `    ${table1.schemaName || rel.entity1} }o--o{ ${table2.schemaName || rel.entity2} : "${rel.schemaName}"`; }
        }
        if (line && mode !== 'tablesonly') mermaid += line + '\n';
        else if (line && mode === 'tablesonly') {
          const involvedTables = rel.type === 'ManyToMany' ? [rel.entity1, rel.entity2] : [rel.referencedEntity, rel.referencingEntity];
          const allInCapturedTables = involvedTables.every(t => collectedData.tables[t]);
          if (allInCapturedTables) mermaid += line + '\n';
        }
      });
      return mermaid;
    };
    const startRecording = () => {
      isRecording = true;
      lastRecordedEntity = currentEntity;
      recordingIntervalId = setInterval(checkAndCaptureCurrentTable, 500);
      startBtn.disabled = true; startBtn.style.opacity = '0.5';
      stopBtn.disabled = false; stopBtn.style.opacity = '1';
      recordingIndicator.style.display = 'block'; recordingText.style.display = 'block';
      setStatus('ðŸ”´ Recording active. Navigate to any table (via subgrid, lookup, or URL) - tables will be auto-captured!');
      addLog('Recording started', 'info');
    };
    const stopRecording = () => {
      isRecording = false;
      if (recordingIntervalId) { clearInterval(recordingIntervalId); recordingIntervalId = null; }
      startBtn.disabled = false; startBtn.style.opacity = '1';
      stopBtn.disabled = true; stopBtn.style.opacity = '0.5';
      recordingIndicator.style.display = 'none'; recordingText.style.display = 'none';
      setStatus('â¸ Recording stopped. ' + Object.keys(collectedData.tables).length + ' tables captured.');
      addLog('Recording stopped', 'info');
    };
    startBtn.addEventListener('click', startRecording);
    stopBtn.addEventListener('click', stopRecording);
    captureBtn.addEventListener('click', async () => { const pc2 = Xrm.Utility.getPageContext && Xrm.Utility.getPageContext(); const entity = (pc2 && pc2.input && pc2.input.entityName) || (Xrm.Page && Xrm.Page.data && Xrm.Page.data.entity && Xrm.Page.data.entity.getEntityName && Xrm.Page.data.entity.getEntityName()); if (!entity) { setStatus('No current table found to capture.', true); return; } if (entity !== currentEntity) { currentEntity = entity; currentEntityName.textContent = entity; } await analyzeTable(entity); });
    exportJsonBtn.addEventListener('click', () => { if (Object.keys(collectedData.tables).length === 0) { alert('No data to export.'); return; } const mode = document.querySelector('input[name="mermaidMode"]:checked').value; const hideSelfRef = document.getElementById('hide-self-ref').checked; const filteredTables = {}; Object.entries(collectedData.tables).forEach(function(entry) { const key = entry[0]; const table = entry[1]; const filteredFields = getFieldsForMode(table, mode); filteredTables[key] = { logicalName: table.logicalName, schemaName: table.schemaName, displayName: table.displayName, primaryIdAttribute: table.primaryIdAttribute, primaryNameAttribute: table.primaryNameAttribute, entitySetName: table.entitySetName, description: table.description, fields: filteredFields, customFields: table.customFields, relationshipsCount: table.relationshipsCount }; }); const filteredRelationships = filterRelationshipsForMode(collectedData.relationships, mode, filteredTables, hideSelfRef); const exportData = { tables: filteredTables, relationships: filteredRelationships, relatedTables: Array.from(collectedData.relatedTables), config: { mermaidMode: mode, hideSelfReferencing: hideSelfRef }, exportedAt: new Date().toISOString(), version: '1.3' }; const totalFields = Object.values(filteredTables).reduce(function(sum, t) { return sum + (t.fields ? t.fields.length : 0); }, 0); const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' }); const url = URL.createObjectURL(blob); const a = ce('a'); a.href = url; a.download = 'erd-data-' + mode + '-' + Date.now() + '.json'; a.click(); URL.revokeObjectURL(url); setStatus('âœ“ JSON exported: ' + Object.keys(filteredTables).length + ' tables, ' + totalFields + ' fields, ' + filteredRelationships.length + ' relationships'); });
    exportMermaidBtn.addEventListener('click', () => { if (Object.keys(collectedData.tables).length === 0) { alert('No data to export.'); return; } const mode = document.querySelector('input[name="mermaidMode"]:checked').value; const hideSelfRef = document.getElementById('hide-self-ref').checked; const mermaidCode = generateMermaid(mode, hideSelfRef); const modeLabel = mode === 'optimized' ? 'optimized' : mode === 'tablesonly' ? 'tables' : 'full'; const blob = new Blob([mermaidCode], { type: 'text/plain' }); const url = URL.createObjectURL(blob); const a = ce('a'); a.href = url; a.download = `erd-diagram-${modeLabel}-${Date.now()}.mmd`; a.click(); URL.revokeObjectURL(url); setStatus(`âœ“ Mermaid ERD (${mode === 'optimized' ? 'Optimized' : mode === 'tablesonly' ? 'Tables Only' : 'Complete'}) exported`); });
    clearBtn.addEventListener('click', () => { if (!confirm('Really delete all captured data?')) return; collectedData = { tables: {}, relationships: [], relatedTables: new Set() }; addLog('Cleared all data', 'info'); updateStats(); updateTablesList(); updateRelatedTablesList(); setStatus('All data cleared.'); });
    
    // View Mermaid ERD functionality
    viewMermaidBtn.addEventListener('click', () => { if (Object.keys(collectedData.tables).length === 0) { alert('No data to visualize. Capture some tables first.'); return; } const cv = getColors(); const viewerOverlay = window.__lvlUpOverlay.createOverlay('ERD Diagram Viewer', { width: 1200, rootId: 'erd-viewer-overlay' }); if (!viewerOverlay) return; viewerOverlay.body.style.maxHeight = '80vh'; viewerOverlay.body.style.overflowY = 'auto'; let viewerHideSelfRef = document.getElementById('hide-self-ref').checked; const loadingDiv = txt(style(ce('div'), `padding:40px;text-align:center;color:${cv.textMuted};font-size:14px;`), 'â³ Loading Mermaid renderer...'); viewerOverlay.body.appendChild(loadingDiv); if (!window.mermaid) { const script = ce('script'); script.src = 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js'; script.onload = () => { window.mermaid.initialize({ startOnLoad: false, theme: ui.host.getAttribute('data-theme') === 'dark' ? 'dark' : 'default', securityLevel: 'loose' }); renderMermaid(); }; script.onerror = () => { clearEl(viewerOverlay.body); viewerOverlay.body.appendChild(txt(style(ce('div'), `padding:40px;text-align:center;color:${cv.textError};`), 'âŒ Failed to load Mermaid library. Check your internet connection.')); }; document.head.appendChild(script); } else { window.mermaid.initialize({ startOnLoad: false, theme: ui.host.getAttribute('data-theme') === 'dark' ? 'dark' : 'default', securityLevel: 'loose' }); renderMermaid(); } function renderMermaid() { clearEl(viewerOverlay.body); const mode = document.querySelector('input[name="mermaidMode"]:checked').value; const mermaidCode = generateMermaid(mode, viewerHideSelfRef); const diagramContainer = style(ce('div'), `padding:20px;background:${cv.bg};border-radius:4px;min-height:400px;`); const filterRow = style(ce('div'), `display:flex;gap:12px;align-items:center;margin-bottom:12px;padding:8px;background:${cv.bgHover};border-radius:4px;`); const hideSelfRefViewCheckbox = ce('input'); hideSelfRefViewCheckbox.type = 'checkbox'; hideSelfRefViewCheckbox.id = 'hide-self-ref-view'; hideSelfRefViewCheckbox.checked = viewerHideSelfRef; const hideSelfRefViewLabel = ce('label'); hideSelfRefViewLabel.htmlFor = 'hide-self-ref-view'; hideSelfRefViewLabel.style.cssText = `font-size:12px;color:${cv.text};cursor:pointer;display:flex;align-items:center;gap:4px;`; hideSelfRefViewLabel.appendChild(hideSelfRefViewCheckbox); hideSelfRefViewLabel.appendChild(document.createTextNode('ðŸ”„ Hide self-referencing relationships')); filterRow.appendChild(hideSelfRefViewLabel); hideSelfRefViewCheckbox.addEventListener('change', () => { viewerHideSelfRef = hideSelfRefViewCheckbox.checked; renderMermaid(); }); diagramContainer.appendChild(filterRow); const diagramDiv = ce('div'); diagramDiv.className = 'mermaid'; diagramDiv.textContent = mermaidCode; diagramContainer.appendChild(diagramDiv); const btnRow = style(ce('div'), `display:flex;gap:8px;margin-top:16px;padding:12px;background:${cv.bgHover};border-radius:4px;`); const copyBtn = txt(ce('button'), 'ðŸ“‹ Copy Code'); copyBtn.style.cssText = `flex:1;padding:8px 16px;background:${cv.primary};color:${cv.textOnPrimary};border:none;border-radius:4px;cursor:pointer;font-weight:600;`; copyBtn.onclick = () => { navigator.clipboard.writeText(mermaidCode).then(() => alert('Mermaid code copied to clipboard!')).catch(() => alert('Failed to copy to clipboard')); }; const downloadBtn = txt(ce('button'), 'ðŸ’¾ Download'); downloadBtn.style.cssText = `flex:1;padding:8px 16px;background:${cv.success};color:${cv.textOnPrimary};border:none;border-radius:4px;cursor:pointer;font-weight:600;`; downloadBtn.onclick = () => { const blob = new Blob([mermaidCode], { type: 'text/plain' }); const url = URL.createObjectURL(blob); const a = ce('a'); a.href = url; a.download = `erd-diagram-${mode}-${Date.now()}.mmd`; a.click(); URL.revokeObjectURL(url); }; const closeBtn = txt(ce('button'), 'âœ– Close'); closeBtn.style.cssText = `flex:1;padding:8px 16px;background:${cv.textMuted};color:${cv.textOnPrimary};border:none;border-radius:4px;cursor:pointer;font-weight:600;`; closeBtn.onclick = () => viewerOverlay.closeOverlay(); btnRow.appendChild(copyBtn); btnRow.appendChild(downloadBtn); btnRow.appendChild(closeBtn); diagramContainer.appendChild(btnRow); viewerOverlay.body.appendChild(diagramContainer); try { window.mermaid.run({ nodes: [diagramDiv] }); addLog('ERD diagram viewed', 'info'); } catch (ex) { console.error(ex); clearEl(diagramContainer); diagramContainer.appendChild(txt(style(ce('div'), `padding:40px;text-align:center;color:${cv.textError};`), 'âŒ Error rendering diagram: ' + ex.message)); } } });
    
    // Import JSON functionality
    importJsonBtn.addEventListener('click', () => { const input = ce('input'); input.type = 'file'; input.accept = '.json'; input.onchange = async (e) => { try { const file = e.target.files[0]; if (!file) return; const text = await file.text(); const data = JSON.parse(text); if (!data.tables || typeof data.tables !== 'object') { alert('Invalid JSON format. Expected data with tables object.'); return; } collectedData.tables = data.tables || {}; collectedData.relationships = data.relationships || []; collectedData.relatedTables = new Set(data.relatedTables || []); let configRestored = false; if (data.config) { if (data.config.mermaidMode) { const modeRadio = document.getElementById('mode-' + (data.config.mermaidMode === 'optimized' ? 'opt' : data.config.mermaidMode === 'full' ? 'full' : data.config.mermaidMode === 'tablesonly' ? 'tables' : 'custom')); if (modeRadio) { modeRadio.checked = true; configRestored = true; } } if (typeof data.config.hideSelfReferencing === 'boolean') { const hideSelfRefCheckbox = document.getElementById('hide-self-ref'); if (hideSelfRefCheckbox) { hideSelfRefCheckbox.checked = data.config.hideSelfReferencing; configRestored = true; } } } else { const hasCustomFields = Object.values(collectedData.tables).some(t => t.customFields && Array.isArray(t.customFields) && t.customFields.length > 0); if (hasCustomFields) { const customModeRadio = document.getElementById('mode-custom'); if (customModeRadio) { customModeRadio.checked = true; } } } addLog('Imported ' + Object.keys(collectedData.tables).length + ' tables from JSON', 'info'); updateStats(); updateTablesList(); updateRelatedTablesList(); setStatus('âœ“ Imported ' + Object.keys(collectedData.tables).length + ' tables from JSON' + (configRestored ? ' (config restored)' : '')); } catch (ex) { console.error(ex); alert('Error importing JSON: ' + ex.message); addLog('Error importing JSON: ' + ex.message, 'error'); } }; input.click(); });
    
    // Import Mermaid functionality
    importMermaidBtn.addEventListener('click', () => { const input = ce('input'); input.type = 'file'; input.accept = '.mmd,.mermaid,.txt'; input.onchange = async (e) => { try { const file = e.target.files[0]; if (!file) return; const text = await file.text(); const lines = text.split('\n'); let tablesFound = 0; lines.forEach(line => { const match = line.match(/^\s*(\w+)\s+\x7b/); if (match) { const tableName = match[1]; if (!collectedData.tables[tableName]) { collectedData.tables[tableName] = { logicalName: tableName, schemaName: tableName, displayName: tableName, fields: [], relationshipsCount: 0 }; tablesFound++; } } }); if (tablesFound > 0) { addLog(`Imported ${tablesFound} tables from Mermaid diagram`, 'info'); updateStats(); updateTablesList(); updateRelatedTablesList(); setStatus(`âœ“ Imported ${tablesFound} table names from Mermaid. Capture them to get full details.`); alert(`Imported ${tablesFound} table names. Use "Capture Current Table" on each to get full field and relationship details.`); } else { alert('No tables found in Mermaid file.'); addLog('No tables found in Mermaid file', 'warning'); } } catch (ex) { console.error(ex); alert('Error importing Mermaid: ' + ex.message); addLog('Error importing Mermaid: ' + ex.message, 'error'); } }; input.click(); });
    
    // Settings dialog
    function showSettings() { const settingsOverlay = window.__lvlUpOverlay.createOverlay('Settings', { width: 500, rootId: 'erd-settings-overlay' }); if (!settingsOverlay) return; let currentMode = ui.host.getAttribute('data-theme') === 'dark' ? 'dark' : 'light'; const colors = getColors(); const settingsContent = ce('div'); const modeTabsDiv = style(ce('div'), 'display:flex;gap:8px;margin-bottom:16px;'); const lightTab = txt(ce('button'), 'â˜€ï¸ Light Mode'); const darkTab = txt(ce('button'), 'ðŸŒ™ Dark Mode'); const tabStyle = (isActive) => `flex:1;padding:8px 16px;border:none;background:${isActive ? colors.primary : colors.bgHover};color:${isActive ? colors.textOnPrimary : colors.text};border-radius:4px;cursor:pointer;font-weight:600;`; lightTab.style.cssText = tabStyle(currentMode === 'light'); darkTab.style.cssText = tabStyle(currentMode === 'dark'); const colorInputsContainer = ce('div'); const colorInputs = {}; const hexInputs = {}; const renderColorInputs = (mode) => { clearEl(colorInputsContainer); colorInputs[mode] = {}; hexInputs[mode] = {}; const modeColors = (customColors && customColors[mode]) || defaultColors[mode]; Object.keys(defaultColors[mode]).forEach(key => { const row = style(ce('div'), 'display:flex;align-items:center;gap:8px;margin-bottom:10px;'); const label = txt(style(ce('label'), 'flex:1;font-size:13px;color:' + colors.text + ';'), key); const colorPicker = ce('input'); colorPicker.type = 'color'; colorPicker.value = modeColors[key]; colorPicker.style.cssText = 'width:60px;height:32px;border:1px solid ' + colors.border + ';border-radius:4px;cursor:pointer;'; colorInputs[mode][key] = colorPicker; const hexInput = ce('input'); hexInput.type = 'text'; hexInput.value = modeColors[key]; hexInput.maxLength = 7; hexInput.placeholder = '#000000'; hexInput.style.cssText = 'width:80px;padding:4px 8px;border:1px solid ' + colors.border + ';border-radius:4px;font-family:monospace;font-size:12px;text-transform:uppercase;'; hexInputs[mode][key] = hexInput; const preview = style(ce('div'), `width:40px;height:32px;background:${modeColors[key]};border:1px solid ${colors.border};border-radius:4px;`); const syncColor = (newColor) => { if (/^#[0-9A-Fa-f]{6}$/.test(newColor)) { colorPicker.value = newColor; hexInput.value = newColor.toUpperCase(); preview.style.background = newColor; } }; colorPicker.addEventListener('input', () => { syncColor(colorPicker.value); }); hexInput.addEventListener('input', () => { const val = hexInput.value.trim(); if (val.charAt(0) !== '#' && val.length > 0) { hexInput.value = '#' + val; } syncColor(hexInput.value); }); hexInput.addEventListener('blur', () => { if (!/^#[0-9A-Fa-f]{6}$/.test(hexInput.value)) { hexInput.value = colorPicker.value; } }); row.appendChild(label); row.appendChild(colorPicker); row.appendChild(hexInput); row.appendChild(preview); colorInputsContainer.appendChild(row); }); }; renderColorInputs(currentMode); lightTab.onclick = () => { currentMode = 'light'; lightTab.style.cssText = tabStyle(true); darkTab.style.cssText = tabStyle(false); renderColorInputs('light'); }; darkTab.onclick = () => { currentMode = 'dark'; lightTab.style.cssText = tabStyle(false); darkTab.style.cssText = tabStyle(true); renderColorInputs('dark'); }; modeTabsDiv.appendChild(lightTab); modeTabsDiv.appendChild(darkTab); settingsContent.appendChild(modeTabsDiv); settingsContent.appendChild(colorInputsContainer); const btnRow = style(ce('div'), 'display:flex;gap:8px;margin-top:16px;'); const saveBtn = txt(ce('button'), 'ðŸ’¾ Save'); saveBtn.style.cssText = `flex:1;padding:8px 16px;background:${colors.primary};color:${colors.textOnPrimary};border:none;border-radius:4px;cursor:pointer;font-weight:600;`; const resetBtn = txt(ce('button'), 'ðŸ”„ Reset to Defaults'); resetBtn.style.cssText = `flex:1;padding:8px 16px;background:${colors.bgHover};color:${colors.text};border:1px solid ${colors.border};border-radius:4px;cursor:pointer;font-weight:600;`; const cancelBtn = txt(ce('button'), 'âœ– Cancel'); cancelBtn.style.cssText = `flex:1;padding:8px 16px;background:${colors.bgHover};color:${colors.text};border:1px solid ${colors.border};border-radius:4px;cursor:pointer;font-weight:600;`; saveBtn.onclick = () => { const newColors = { light: {}, dark: {} }; ['light', 'dark'].forEach(mode => { if (colorInputs[mode]) { Object.keys(colorInputs[mode]).forEach(key => { newColors[mode][key] = colorInputs[mode][key].value; }); } else { newColors[mode] = (customColors && customColors[mode]) || defaultColors[mode]; } }); try { localStorage.setItem('crmab-erdexplorer-colors', JSON.stringify(newColors)); customColors = newColors; addLog('Settings saved', 'info'); settingsOverlay.closeOverlay(); ui.closeOverlay(); requestAnimationFrame(() => { location.reload(); }); } catch (ex) { alert('Error saving settings: ' + ex.message); } }; resetBtn.onclick = () => { if (!confirm('Reset all color settings to defaults?')) return; try { localStorage.removeItem('crmab-erdexplorer-colors'); customColors = null; addLog('Settings reset to defaults', 'info'); settingsOverlay.closeOverlay(); ui.closeOverlay(); requestAnimationFrame(() => { location.reload(); }); } catch (ex) { alert('Error resetting settings: ' + ex.message); } }; cancelBtn.onclick = () => settingsOverlay.closeOverlay(); btnRow.appendChild(saveBtn); btnRow.appendChild(resetBtn); btnRow.appendChild(cancelBtn); settingsContent.appendChild(btnRow); settingsOverlay.body.appendChild(settingsContent); };
    
    // Logs dialog
    function showLogViewer() { const cl = getColors(); const logsOverlay = window.__lvlUpOverlay.createOverlay('Activity Logs', { width: 600, rootId: 'erd-logs-overlay' }); if (!logsOverlay) return; const logsContent = ce('div'); if (activityLog.length === 0) { logsContent.appendChild(txt(style(ce('div'), `padding:20px;text-align:center;color:${cl.textMuted};`), 'No activity logged yet.')); } else { activityLog.slice().reverse().forEach(log => { const logRow = style(ce('div'), `padding:8px 12px;border-bottom:1px solid ${cl.borderLight};font-size:12px;color:${log.type === 'error' ? cl.textError : cl.textMuted};`); const time = style(ce('span'), 'font-weight:600;margin-right:8px;'); time.textContent = log.timestamp.toLocaleTimeString(); const msg = ce('span'); msg.textContent = log.message; logRow.appendChild(time); logRow.appendChild(msg); logsContent.appendChild(logRow); }); } const clearLogsBtn = txt(ce('button'), 'ðŸ—‘ Clear Logs'); clearLogsBtn.style.cssText = `width:100%;margin-top:12px;padding:8px;background:${cl.danger};color:${cl.textOnPrimary};border:none;border-radius:4px;cursor:pointer;font-weight:600;`; clearLogsBtn.onclick = () => { if (!confirm('Clear all logs?')) return; activityLog = []; logsOverlay.closeOverlay(); showLogViewer(); }; logsContent.appendChild(clearLogsBtn); logsOverlay.body.appendChild(logsContent); };
    
    // Footer buttons
    if (ui.footer) { const settingsBtn = txt(ce('button'), String.fromCharCode(9881) + ' Settings'); settingsBtn.style.cssText = `background:transparent;border:1px solid ${c.border};color:${c.text};padding:6px 12px;border-radius:4px;cursor:pointer;font-weight:600;font-size:12px;`; settingsBtn.onclick = showSettings; const logBtn = txt(ce('button'), String.fromCharCode(128276) + ' Logs'); logBtn.style.cssText = `background:transparent;border:1px solid ${c.border};color:${c.text};padding:6px 12px;border-radius:4px;cursor:pointer;font-weight:600;font-size:12px;margin-left:8px;`; logBtn.onclick = showLogViewer; ui.footer.insertBefore(settingsBtn, ui.footer.firstChild); ui.footer.insertBefore(logBtn, ui.footer.children[1]); }
    
    // Cleanup on overlay close
    const originalClose = ui.closeOverlay; if (originalClose) { ui.closeOverlay = function() { isRecording = false; if (recordingIntervalId) { clearInterval(recordingIntervalId); recordingIntervalId = null; } originalClose.call(ui); }; }
    
    if (currentEntity) { setStatus('Current table found. Ready to capture.'); }
  } catch (ex) {
    console.error(ex);
    const c2 = getColors();
    const err = ce('div');
    err.style.cssText = `color:${c2.textError};margin-top:8px;padding:8px;background:${c2.bgError};border-radius:4px;`;
    err.textContent = 'Error: ' + (ex.message || ex);
    ui.body.appendChild(err);
  }
})();
